# GNU Make

GNU Make is a build automation tool that automatically builds executable programs and libraries from source code by reading files called **Makefiles**. A Makefile specifies how to derive the target program from its source files using a set of rules, dependencies, and commands.

## Installation

Install GNU Make with your preferred [package manager](https://en.wikipedia.org/wiki/List_of_software_package_management_systems):

```shell
# On Ubuntu (WSL2)
sudo apt update
sudo apt install make

# On macOS, we can use Homebrew
# Note that Xcode Command Line Tools comes with `make` pre-installed
brew update
brew install make

# On other OS, google "<OS-name> install clang-format" to check for specific commands
# Once you install clang-format, verify it with the following command
make --version
# This should display something like "GNU Make 3.81"
```

### Basic Structure

A simple Makefile consists of "rules" with the following shape:

```text
target: prerequisites
	recipe
```

* **target** - A target is usually the name of a file that is generated by a program; examples of targets are *executable* or *object files*. A target can also be the name of an action to carry out, such as `clean`. 
* **prerequisite** (also known as **dependency**) - A prerequisite is a file that is used as input to create the target. A target often depends on several prerequisites.
* **recipe** - A recipe is an action that Make carries out. A recipe may have more than one command, either on the same line or each on its own line.

> [!NOTE]
>
> You need to put a **tab character** at the beginning of every recipe line.

Whenever we need to create a `main.o` file, we will first check if `main.cpp` exists, and then run `g++ -c main.cpp` to produce `main.o`. Here, `main.o` is the target, `main.cpp` is the only prerequisite (or dependency, ingredient), and the command serves as the recipe for producing `main.o` with `main.cpp`.

```makefile
# In `Makefile`
main.o: main.cpp
	g++ -c main.cpp
```

Now, when we run the `make main.o` command, Make will do the following things in order:

* Check if `Makefile` is in the working directory. If it does not exist, the following error message will be displayed:

  ```text
  make: *** No targets specified and no makefile found.  Stop.
  ```

* Parse `Makefile` and all the rules inside.

* Check if the `main.o` target exists. If it does not exist, the following error message will be displayed:

  ```text
  make: *** No rule to make target `main.o'.  Stop
  ```

* Check if all prerequisites exist. In this case, the existence of `main.c` will be checked. If `main.c` does not exist, it will go on to check if a target named `main.c` exists, which we will talk about later. If no target is named `main.c`, Make will stop because the prerequisite is not met, and the following error message will be displayed:

  ```
  make: *** No rule to make target `main.c', needed by `main.o'.  Stop.
  ```

* Run the recipe, which contains only one command in our case:

  ```bash
  $ g++ -c main.cpp
  ```

Now, let's take a look at an example where the target is an action instead of a file:

```makefile
# In `Makefile`
clean:
	rm -f *.o
```

The target `clean` has no prerequisites. When we run the `make clean` command, Make simply carries out the recipe, that is, `rm -f *.o`. It is a command used to clean up all the files ending with `.o` (object files).

### Transitive Dependencies

A transitive dependency refers to a situation where a target is determined by a dependency, and the dependency, in turn, is a target and determined by others. This frequently occurs in `Makefile`.

```makefile
app: main.o demo.o
	g++ -o app main.o demo.o

main.o: main.cpp
	g++ -c main.cpp

demo.o: demo.cpp
	g++ -c demo.cpp
```

In this example, `app` is an executable file linked from `main.o` and `demo.o`, which serve as the dependencies of the target `app`. When the command `make app` is run, Make first checks if `main.o` and `demo.o` already exists. If not, it continues to look for targets with the same names to make them out. After `main.o` and `demo.o` are in place, the recipe associated with the `app` target will be carried out. Therefore, the execution order of the commands is as follows:

```shell
$ g++ -c main.cpp
$ g++ -c demo.cpp
$ g++ -o app main.o demo.o
```

### Automatic Variables

You may already notice that we often include the target name or prerequisites in our recipe. To simplify our `Makefile`, we can apply automatic variables to reduce repetitions.

```makefile
app: main.o demo.o
	g++ -o $@ $^

main.o: main.cpp
	g++ -c $<

demo.o: demo.cpp
	g++ -c $<
```

This example introduces three automatic variables:

* **$@** - The file name of the target of the rule
* **$^** - The names of all the prerequisites, with spaces between them.
* **$<** - The name of the first prerequisite.

There are also many other automatic variables, but you may not want to know them unless you want to become an expert in GNU Make.

### Variables

When using `g++`, we often pass in multiple options repeatedly. For example:

```makefile
main.o: main.cpp
	g++ --std=c++20 -Wall -Werror -pedantic -g -c $<

demo.o: demo.cpp
	g++ --std=c++20 -Wall -Werror -pedantic -g -c $<
```

In this example, both rules use the same set of options for the compiler. To avoid redundancy and make the `Makefile`easier to maintain, we can extract the common options into variables:

```makefile
COMPILER = g++
OPTS = --std=c++20 -Wall -Werror -pedantic -g

main.o: main.cpp
	$(COMPILER) $(OPTS) -c $<

demo.o: demo.cpp
	$(COMPILER) $(OPTS) -c $<
```

### Wildcard Characters

You may already find that after we use the `$<` automatic variable, the recipes of `main.o` and `demo.o` are exactly the same. So, do we have to write the same recipe 20 times, if we have 20 different `.cpp` files? Thankfully, wildcard characters help us out in this scenario.

```makefile
COMPILER = g++
OPTS = --std=c++20 -Wall -Werror -pedantic -g

%.o: %.cpp
	$(COMPILER) $(OPTS) -c $<
```

Here, we use the wildcard character `%` to match any filenames, and the `%` in the prerequisite list will be replaced by the matched filename in the target. This is so widely used that almost every C++ project has these two lines or something similar.

## Example

Let's take a look at a real example

```makefile
COMPILER = g++
CFLAGS = --std=c++17 -Wall -Werror -pedantic -g
LIB = -lsfml-graphics -lsfml-window -lsfml-system
DEPS = PTree.hpp
OBJECTS = PTree.o main.o
PROGRAM = PTree

.PHONY: all clean lint run

all: $(PROGRAM)

%.o: %.cpp $(DEPS)
	$(COMPILER) $(CFLAGS) -c $<

$(PROGRAM): $(OBJECTS)
	$(COMPILER) $(CFLAGS) -o $@ $^ $(LIB)

run: $(PROGRAM)
	./$(PROGRAM) 160 9 30
	make clean

clean:
	rm -f *.o $(PROGRAM)
```

**[Variables]**

* `COMPILER` - The compiler used in this project. It can be `clang++` or other C++ compilers.
* `CFLAGS` - Options passed in to the compiler.
* `LIB` - The libraries used in the project.
* `DEPS` - C++ header files.
* `OBJECTS` - C++ source files.
* `PROGRAM` - The name of the executable file to make.

**[Targets]**

* `all` - The default target. If no target is specified when running `make`, this target will be run. 
* `%.o: %.cpp $(DEPS)` - Make any C++ source file into an object file.
* `$(PROGRAM): $(OBJECTS)` - Make the executable file.
* `run: $(PROGRAM)` - An action that runs the executable file with specific arguments. After finishing the program, the command `make clean` will be run.
* `clean` - An action that cleans up all object files as well as the executable file.

> [!IMPORTANT]
>
> Take 5 minutes to think about, better off writing down on paper, what commands will be run after we execute the `make run` command. Then, check if your answer is the same as the following output.

```shell
$ make run
g++ --std=c++17 -Wall -Werror -pedantic -g -c PTree.cpp
g++ --std=c++17 -Wall -Werror -pedantic -g -c main.cpp
g++ --std=c++17 -Wall -Werror -pedantic -g -o PTree PTree.o main.o -lsfml-graphics -lsfml-window -lsfml-system
./PTree 160 9 30 && make clean
rm -f *.o PTree
```

